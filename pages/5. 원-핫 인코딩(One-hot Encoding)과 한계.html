<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>텍스트 벡터화 : 원-핫 인코딩에서 워드 임베딩까지</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* 1. Core Styles */
        :root {
            --color-text-primary: #212529;
            --color-text-secondary: #6c757d;
            --color-border: #dee2e6;
            --color-bg-white: #ffffff;
            --color-bg-subtle: #f8f9fa; /* 연한 회색 */
            --font-family-base: 'Noto Sans KR', sans-serif;
        }

        body {
            font-family: var(--font-family-base);
            font-size: 1rem;
            line-height: 1.7;
            background-color: var(--color-bg-white);
            color: var(--color-text-primary);
            margin: 0;
            padding: 4rem 1rem;
            -webkit-font-smoothing: antialiased;
        }

        /* 2. Typography */
        h1, h2, h3, h4 {
            font-weight: 700;
            line-height: 1.3;
            margin-top: 0;
        }
        h1 { font-size: 2.5rem; font-weight: 900; margin-bottom: 0.5rem; }
        h2 { font-size: 2rem; margin-bottom: 0.75rem; }
        h3 { font-size: 1.5rem; margin-top: 0; margin-bottom: 1.5rem; }
        h4 { font-size: 1.2rem; margin-top: 0; margin-bottom: 1rem; }
        p { margin-top: 0; margin-bottom: 1rem; }
        b, strong { font-weight: 700; }
        pre {
            background-color: #f5f7fa;
            border: 1px solid #e3e8f0;
            padding: 1.5rem;
            border-radius: 0.5rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* 3. Layout & Components */
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 3rem;
        }
        .header p {
            font-size: 1.125rem;
            color: var(--color-text-secondary);
            max-width: 800px;
            margin: 0 auto;
        }
        .section-title {
            text-align: center;
            margin: 4rem 0 2rem 0;
        }
        hr {
            border: none;
            border-top: 1px solid var(--color-border);
            margin: 4rem auto;
        }
        
        /* === [추가] 전환 텍스트 스타일 === */
        .transition-text {
            text-align: center;
            font-size: 1.1rem;
            color: var(--color-text-secondary);
            max-width: 800px;
            margin: 2.5rem auto 0 auto;
            padding: 2rem;
            background-color: var(--color-bg-subtle);
            border-radius: 0.75rem;
            border: 1px solid var(--color-border);
        }

        /* Card System */
        .card {
            border: 1px solid var(--color-border);
            border-radius: 0.75rem;
            padding: 2.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.02);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.07);
        }
        .highlight-gray {
            background-color: var(--color-bg-subtle);
        }
        /* === [추가] 오렌지색 카드 === */
        .highlight-orange {
            background-color: #fffaf0; /* FloralWhite */
            border-color: #ffebd7;
        }
        .sub-card {
            background-color: var(--color-bg-white);
            border: 1px solid var(--color-border);
            border-radius: 0.5rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
        }
        .sub-card:first-of-type {
            margin-top: 0;
        }
        .sub-card p, .sub-card ul, .sub-card ol {
            margin-bottom: 0;
        }
        .sub-card ul, .sub-card ol {
            padding-left: 20px;
        }
    </style>
</head>
<body>

    <main class="container">
        <header class="header">
            <h1>텍스트 벡터화<br>원-핫 인코딩에서 워드 임베딩까지</h1>
            <p>자연어 처리(NLP)에서 텍스트를 기계가 이해할 수 있는 숫자 <b>벡터(Vector)</b>로 변환하는 것은 필수입니다.<br>이 과정을 <b>벡터화(Vectorization)</b>라 하며, 그 발전 과정을 알아보겠습니다.</p>
        </header>

        <div class="section-title">
            <h2>1. 원-핫 인코딩 (One-hot Encoding)</h2>
        </div>

        <section class="card highlight-gray">
            <p>컴퓨터는 글자를 직접 이해할 수 없기 때문에, 텍스트를 숫자 형태의 벡터(Vector)로 변환하는 '벡터화' 과정이 필수적입니다. <b>원-핫 인코딩은 이 벡터화의 가장 기본적인 방법 중 하나입니다.</b></p>
            <h3>핵심 개념과 작동 방식</h3>
            <p><strong>원-핫 인코딩</strong>은 단어를 표현하는 가장 기초적이고 직관적인 방법으로, 단어장의 모든 단어에 고유 번호를 부여하고 <b>해당 번호의 위치만 1로, 나머지는 모두 0으로</b> 표시하는 방식입니다.</p>

            <div class="sub-card">
                <h4>작동 방식</h4>
                <ol>
                    <li><b>단어장(Vocabulary) 생성</b><br>전체 텍스트에서 고유한 단어들을 모두 모아 '단어:고유번호' 형태의 사전을 만듭니다.</li>
                    <li style="margin-top:1rem;"><b>정수 인코딩(Indexing)</b><br>단어장의 각 단어에 0부터 시작하는 고유 정수(Index)를 할당합니다.</li>
                    <li style="margin-top:1rem;"><b>벡터 변환</b><br>단어장 크기와 동일한 차원의 0으로 채워진 벡터를 생성한 뒤, 해당 단어의 인덱스 위치 값만 1로 변경합니다.</li>
                </ol>
            </div>
            <div class="sub-card">
                <h4>명확한 한계</h4>
                <ol>
                    <li><b>고차원 / 희소 벡터 (Sparsity)</b><br>단어 수가 3만 개면 벡터의 차원도 3만 차원이 됩니다.<br><b>메모리 낭비가 심하고 계산이 비효율적입니다.</b></li>
                    <li style="margin-top:1rem;"><b>의미 관계 표현 불가</b><br>모든 단어 벡터는 서로 수학적으로 독립적입니다.<br><b>즉, '컴퓨터-노트북'의 관계와 '컴퓨터-사과'의 관계에 아무런 차이가 없습니다.</b></li>
                </ol>
            </div>
        </section>

        <section class="card highlight-gray">
            <h3>예시 : 원-핫 벡터의 한계</h3>
            <div class="sub-card">
                <h4>단어장 및 벡터</h4>
                <pre>단어장 : {'사과':0, '바나나':1, '컴퓨터':2, '노트북':3}

사과   : [1, 0, 0, 0]
컴퓨터 : [0, 0, 1, 0]
노트북 : [0, 0, 0, 1]</pre>
            </div>
            <div class="sub-card">
                <h4>문제점</h4>
                <p>'컴퓨터'와 '노트북' 사이의 거리, 그리고 '컴퓨터'와 '사과' 사이의 거리가 수학적으로 동일합니다.<br>이는 단어의 의미 관계를 전혀 표현하지 못함을 보여줍니다.</p>
            </div>
        </section>

        <div class="transition-text">
            <p>이처럼 원-핫 인코딩은 단어의 의미를 담지 못하는 명확한 한계가 있었습니다.<br>이러한 문제를 해결하기 위해, 단어의 의미를 벡터에 <b>'임베딩(Embedding)'</b>하는 새로운 접근 방식이 등장했습니다. 이제 워드 임베딩에 대해 알아보겠습니다.</p>
        </div>
        <hr>

        <div class="section-title">
            <h2>2. 워드 임베딩 (Word Embedding)</h2>
        </div>

        <section class="card highlight-gray">
            <h3>핵심 개념과 아이디어</h3>
            <p><strong>워드 임베딩</strong>은 각 단어를 사용자가 지정한 저차원(예: 100~300차원)의 <strong>밀집 벡터(Dense Vector)</strong>로 표현하는 기술입니다. 이 벡터는 단어의 문법적, 의미적 정보를 압축하여 담고 있는 실수들로 채워져 있습니다.</p>
            <div class="sub-card">
                <h4>핵심 아이디어</h4>
                 <ul>
                    <li><b>분산 표현 (Distributed Representation)</b><br>단어의 의미를 벡터의 여러 차원에 걸쳐 분산시켜 표현합니다.</li>
                    <li style="margin-top:1rem;"><b>의미적 유사도</b><br>의미가 비슷한 단어들은 벡터 공간상에서 서로 가까운 위치에 존재하게 됩니다.</li>
                </ul>
            </div>
        </section>

        <section class="card highlight-gray">
            <h3>예시 : 의미를 담은 벡터</h3>
            <div class="sub-card">
                <h4>계산 예시</h4>
                <pre><b>유사도 계산</b>
cosine_similarity('컴퓨터', '노트북') → 높음 (예: 0.92)
cosine_similarity('컴퓨터', '사과')   → 낮음 (예: 0.15)

<b>관계 유추</b>
vector('왕') - vector('남자') + vector('여자') ≈ vector('여왕')</pre>
            </div>
            <div class="sub-card">
                <h4>결과</h4>
                <p>벡터의 거리와 방향을 통해 '컴퓨터'와 '노트북'이 '사과'보다 훨씬 가깝다는 것을 명확히 알 수 있으며, 단어 간의 추상적인 관계까지 계산할 수 있습니다.</p>
            </div>
        </section>

        <hr>

        <div class="section-title">
            <h2>3. 결론</h2>
        </div>
        <section class="card highlight-orange">
            <h3>단순한 기호에서 의미를 지닌 좌표로</h3>
            <p><strong>원-핫 인코딩</strong>은 단어를 기계가 읽도록 바꾸는 첫 걸음이었지만 의미를 담지 못했습니다.<br><br><strong>워드 임베딩</strong>은 이러한 한계를 극복하고 단어의 '의미'를 벡터 공간의 '좌표'로 표현하는 혁신을 이루었으며, 이 개념은 오늘날 BERT, GPT와 같은 거의 모든 현대 자연어 처리 모델의 근간이 되는 핵심 아이디어입니다.</p>
        </section>
        </main>

</body>
</html>