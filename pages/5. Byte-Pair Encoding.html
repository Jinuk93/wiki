<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BPE (Byte-Pair Encoding) 알고리즘</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* 1. Core Design Philosophy & Technical Specs */
        :root {
            --color-text-primary: #212529;
            --color-text-secondary: #6c757d;
            --color-border: #dee2e6;
            --color-bg-white: #ffffff;
            --color-bg-subtle: #f8f9fa;
            --color-step-icon-bg: #2c3e50;
            --font-family-base: 'Noto Sans KR', sans-serif;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-family-base);
            font-size: 1rem; /* 16px */
            line-height: 1.7;
            background-color: var(--color-bg-white);
            color: var(--color-text-primary);
            margin: 0;
            padding: 4rem 1rem;
            -webkit-font-smoothing: antialiased;
        }

        /* 2. Typography & Hierarchy */
        h1, h2, h3 {
            font-weight: 700;
            line-height: 1.3;
            margin-top: 0;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 900; /* Extra bold for main title */
            margin-bottom: 0.5rem;
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 0.75rem;
        }

        h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        p {
            margin-top: 0;
            margin-bottom: 1rem;
        }
        
        strong, b {
           font-weight: 700;
           color: var(--color-text-primary);
        }
        
        code {
            font-family: Consolas, 'Courier New', monospace;
            background-color: #e9ecef;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-size: 90%;
        }

        /* 3. Component Library & Structure */
        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header, .section-title {
            text-align: center;
            margin-bottom: 3rem;
        }

        .header p, .section-title p {
            font-size: 1.125rem;
            color: var(--color-text-secondary);
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            margin-bottom: 0;
        }

        /* Base Card Style */
        .card {
            background-color: var(--color-bg-white);
            border: 1px solid var(--color-border);
            border-radius: 0.75rem; /* 12px */
            padding: 2rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.02);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        /* Card Hover Effect */
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.07);
        }

        /* Component Variations */
        .step-card {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            padding: 2.5rem;
        }
        
        @media (min-width: 768px) {
            .step-card {
                flex-direction: row;
                align-items: flex-start;
            }
        }
        
        .step-card-content {
            flex: 1;
        }
        
        .step-number {
            flex-shrink: 0;
            width: 50px;
            height: 50px;
            background-color: var(--color-step-icon-bg);
            color: #fff;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem;
            font-weight: 700;
            /* Subtle glitch/3D effect */
            text-shadow: 1px 1px 0px rgba(255, 0, 85, 0.5), -1px -1px 0px rgba(0, 229, 255, 0.5);
        }
        
        .step-card h3 {
            font-size: 1.5rem;
            margin-bottom: 0.75rem;
        }

        /* Nested Aside Block */
        aside {
            background-color: var(--color-bg-subtle);
            border-left: 4px solid var(--color-border);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 0.25rem 0.25rem 0;
            font-size: 0.95rem;
        }
        
        aside p:last-child {
            margin-bottom: 0;
        }
        
        /* Standalone Transition/Conclusion Paragraphs */
        .transition-text {
            text-align: center;
            max-width: 700px;
            margin: 3rem auto;
            font-size: 1.1rem;
            line-height: 1.8;
            color: #495057;
        }
        
        /* 4. Interactivity (Scroll Animation) */
        .fade-in-up {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
        }

        .fade-in-up.visible {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>
<body>

    <main class="container">
        <header class="header fade-in-up">
            <h1>BPE (Byte-Pair Encoding) 알고리즘</h1>
        </header>

        <section class="content-block card fade-in-up">
            <p>BPE는 텍스트를 효율적인 서브워드(Subword) 단위로 분절하기 위한 데이터 압축 알고리즘입니다.<br>서브워드는 <strong>단어(Word)와 글자(Character)</strong>의 장점을 모두 취한 중간 크기의 단위로,<br></vr>OOV(어휘집에 없는 단어) 문제와 글자 토큰화의 비효율성을 동시에 해결합니다.</p>
            <p>BPE의 모든 것을 관통하는 단 하나의 핵심 원리는 다음과 같습니다.</p>
            <aside>
                <p>"데이터에서 <strong>가장 빈번하게 등장하는 연속된 토큰 쌍(pair)을 찾아</strong><br> 하나의 새로운 토큰으로 병합하는 과정을 반복한다."</p>
            </aside>
        </section>

        <div class="section-title fade-in-up">
            <h2>BPE의 학습 과정 (Step-by-Step)</h2>
            <p>BPE는 어떻게 최적의 서브워드 어휘집(Vocabulary)을 만들까요?<br><code>low lowest newest</code> 라는 텍스트를 예시로 학습 과정을 살펴보겠습니다.</p>
        </div>
        
        <div class="steps-grid">
            <article class="step-card card fade-in-up">
                <div class="step-number">1</div>
                <div class="step-card-content">
                    <h3>1단계 : 준비 (Initialization)</h3>
                    <p>먼저 모든 단어를 글자(character) 단위로 분해하고, 단어의 끝을 의미하는<br> 특수 기호 <code>&lt;/w&gt;</code>를 추가합니다. 이 시점의 어휘집은 텍스트에 존재하는 모든 기본 글자들입니다.</p>
                    <aside>
                        <p><strong>분절된 텍스트 :</strong> l o w &lt;/w&gt;, l o w e s t &lt;/w&gt;, n e w e s t &lt;/w&gt;<br>
                        <strong>초기 어휘집 :</strong> {l, o, w, e, s, t, n, &lt;/w&gt;}</p>
                    </aside>
                </div>
            </article>

            <article class="step-card card fade-in-up">
                <div class="step-number">2</div>
                <div class="step-card-content">
                    <h3>2단계 : 반복 병합 (Iterative Merging)</h3>
                    <p>텍스트 전체에서 가장 자주 나타나는 인접한 토큰 쌍을 찾아 새로운 토큰으로 병합하고<br> 어휘집에 추가합니다. 이 과정을 정해진 횟수만큼 반복합니다.</p>
                    <aside>
                        <p><strong>(1회차)</strong> e와 s 쌍이 2번으로 가장 빈번합니다. → <code>es</code>를 병합하고 어휘집에 추가합니다.<br>
                        텍스트 상태 : l o w &lt;/w&gt;, l o w <strong>es</strong> t &lt;/w&gt;, n e w <strong>es</strong> t &lt;/w&gt;<br>
                        어휘집 추가 : es</p>
                        <p><strong>(2회차)</strong> es와 t 쌍이 2번으로 가장 빈번합니다. → <code>est</code>를 병합하고 어휘집에 추가합니다.<br>
                        텍스트 상태 : l o w &lt;/w&gt;, l o w <strong>est</strong> &lt;/w&gt;, n e w <strong>est</strong> &lt;/w&gt;<br>
                        어휘집 추가 : est</p>
                         <p><strong>(3회차)</strong> l과 o 쌍이 2번으로 가장 빈번합니다. → <code>lo</code>를 병합하고 어휘집에 추가합니다.<br>
                        텍스트 상태 : <strong>lo</strong> w &lt;/w&gt;, <strong>lo</strong> w est &lt;/w&gt;, n e w est &lt;/w&gt;<br>
                        어휘집 추가 : lo</p>
                         <p><strong>(4회차)</strong> lo와 w 쌍이 2번으로 가장 빈번합니다. → <code>low</code>를 병합하고 어휘집에 추가합니다.<br>
                        텍스트 상태 : <strong>low</strong> &lt;/w&gt;, <strong>low</strong> est &lt;/w&gt;, n e w est &lt;/w&gt;<br>
                        어휘집 추가 : low</p>
                    </aside>
                </div>
            </article>
        </div>
        
        <p class="transition-text fade-in-up">
            이 과정을 수만 번 반복하면,<br> 자주 사용되는 단어나 의미 있는 형태소(pre, ing 등)들이 통계적으로 어휘집에 등록됩니다.
        </p>

        <div class="section-title fade-in-up">
            <h2>BPE의 강력한 장점</h2>
        </div>

        <section class="content-block card fade-in-up">
            <aside>
                <p><strong>OOV 문제 해결</strong><br>
                : <code>huggingface</code> 같은 처음 보는 단어도 학습된 서브워드 <code>hugg</code>, <code>ing</code>, <code>face</code> 등의 조합으로 표현하여 정보 손실을 최소화합니다.</p>
                <p><strong>효율적인 어휘집 크기</strong><br>
                : 자주 쓰는 단어(<code>low</code>)는 통째로, 드물게 쓰는 단어(<code>lowest</code>)는 조각의 조합(<code>low</code>, <code>est</code>)으로 표현하여 어휘집의 크기를 최적화합니다.</p>
                <p><strong>데이터 기반 분절</strong><br>
                : <code>preprocessing</code>처럼 통계적으로 자주 함께 등장하는 부분은<code>pre</code>, <code>processing</code>과 같이 의미 있는 단위로 분절될 가능성이 높습니다.</p>
            </aside>
        </section>

        <p class="transition-text fade-in-up">
            이러한 장점 덕분에 BPE와 이를 변형한 알고리즘(WordPiece, SentencePiece 등)은<br><strong>GPT, BERT와 같은 현대 NLP 모델의 핵심적인 토큰화 방식</strong>으로 자리 잡았습니다.
        </p>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const animatedElements = document.querySelectorAll('.fade-in-up');

            if ('IntersectionObserver' in window) {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('visible');
                            observer.unobserve(entry.target);
                        }
                    });
                }, {
                    threshold: 0.1
                });

                animatedElements.forEach(el => {
                    observer.observe(el);
                });
            } else {
                // Fallback for older browsers without IntersectionObserver
                animatedElements.forEach(el => {
                    el.classList.add('visible');
                });
            }
        });
    </script>

</body>
</html>