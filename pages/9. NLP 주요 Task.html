<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>주요 NLP Task</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* 1. Core Design Philosophy & Technical Specs */
        :root {
            --color-text-primary: #212529;
            --color-text-secondary: #6c757d;
            --color-border: #dee2e6;
            --color-bg-white: #ffffff;
            --color-bg-subtle: #f8f9fa;
            --color-step-icon-bg: #2c3e50;
            --color-highlight-purple-bg: #f5f3ff; /* 연한 보라색 */
            --color-highlight-purple-border: #e0d8ff;
            --color-highlight-green-bg: #f2fbf5;  /* 연한 녹색 */
            --color-highlight-green-border: #d4f0de;
            --font-family-base: 'Noto Sans KR', sans-serif;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-family-base);
            font-size: 1rem;
            line-height: 1.7;
            background-color: var(--color-bg-white);
            color: var(--color-text-primary);
            margin: 0;
            padding: 4rem 1rem;
            -webkit-font-smoothing: antialiased;
        }

        /* 2. Typography & Hierarchy */
        h1, h2, h3, h4 {
            font-weight: 700;
            line-height: 1.3;
            margin-top: 0;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 0.5rem;
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 0.75rem;
        }

        h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }
        
        h4 {
            font-size: 1.2rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        p {
            margin-top: 0;
            margin-bottom: 1rem;
        }
        
        strong, b {
           font-weight: 700;
           color: var(--color-text-primary);
        }
        
        pre {
            font-family: Consolas, 'Courier New', monospace;
            background-color: #e9ecef;
            padding: 1em;
            border-radius: 4px;
            font-size: 90%;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* 3. Component Library & Structure */
        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin: 0 auto 3rem auto;
        }
        
        /* ▼▼▼ [수정된 부분] section-title 왼쪽 정렬 ▼▼▼ */
        .section-title {
            text-align: left;
            margin: 4rem 0 2rem 0; /* 상하 여백 조정, 좌우 auto 제거 */
        }
        .section-title p,
        .section-title aside {
            max-width: 100%; /* 중앙 정렬을 위한 max-width 제거 */
            margin-left: 0;
            margin-right: 0;
        }
        /* ▲▲▲ [수정된 부분] section-title 왼쪽 정렬 ▲▲▲ */


        /* Base Card Style */
        .card {
            background-color: var(--color-bg-white);
            border: 1px solid var(--color-border);
            border-radius: 0.75rem;
            padding: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.02);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.07);
        }

        /* Component Variations */
        .steps-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
        }

        .step-card {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            padding: 2.5rem;
        }
        
        @media (min-width: 768px) {
            .step-card {
                flex-direction: row;
                align-items: flex-start;
            }
        }
        
        .step-card-content {
            flex: 1;
        }
        
        .step-number {
            flex-shrink: 0;
            width: 50px;
            height: 50px;
            background-color: var(--color-step-icon-bg);
            color: #fff;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem;
            font-weight: 700;
            text-shadow: 1px 1px 0px rgba(255, 0, 85, 0.5), -1px -1px 0px rgba(0, 229, 255, 0.5);
        }
        
        .model-compare-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
            align-items: start;
        }

        @media (min-width: 992px) {
            .model-compare-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .model-card > h3 {
            font-size: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--color-border);
        }

        /* Nested Aside Block */
        aside {
            background-color: var(--color-bg-subtle);
            border-left: 4px solid var(--color-border);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 0.25rem 0.25rem 0;
            font-size: 0.95rem;
        }
        
        /* ▼▼▼ [수정된 부분] 하이라이트 색상 추가 ▼▼▼ */
        .highlight-purple {
            background-color: var(--color-highlight-purple-bg);
            border-color: var(--color-highlight-purple-border);
        }
        .highlight-green {
            background-color: var(--color-highlight-green-bg);
            border-color: var(--color-highlight-green-border);
        }
        /* ▲▲▲ [수정된 부분] 하이라이트 색상 추가 ▲▲▲ */

        /* 4. Interactivity (Scroll Animation) */
        .fade-in-up {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
        }

        .fade-in-up.visible {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>
<body>

    <main class="container">
        <header class="header fade-in-up">
            <h1>주요 NLP Task</h1>
            <p>이렇게 생성된 단어 벡터(임베딩)들은 다양한 NLP 모델의 입력값으로 사용됩니다.</p>
        </header>

        <section class="section-title fade-in-up">
            <h2>1. 기계 번역 (Machine Translation) 🤖</h2>
            <p>하나의 언어로 된 문장을 다른 언어의 문장으로 자동 번역하는 기술입니다.</p>
            <aside>먼저 한 언어(영어)를 듣고 전체 내용의 의미(문맥)를 완벽히 파악한 뒤(인코더) 그 의미를 바탕으로<br> 다른 언어(한국어)로 된 문장을 자연스럽게 생성(디코더)</aside>
        </section>
        
        <div class="steps-grid fade-in-up">
            <article class="step-card card">
                <div class="step-number">1</div>
                <div class="step-card-content">
                    <h3>입력 처리 (인코더)</h3>
                    <p>영어 문장 <strong>"I love a dog"</strong>이 토큰화 및 임베딩 과정을 거쳐 벡터의 나열로 변환됩니다.<br> 인코더는 이 벡터 시퀀스를 입력받아 문장 전체의 의미를 압축한 <strong>문맥 벡터(Context Vector)</strong>를 생성합니다.</p>
                    <aside>
                        <p><strong>1. 토큰화 (Tokenization) :</strong><br>
                        입력 문장을 토큰 단위로 분절합니다.<br>
                        "I love a dog ." → ['i', 'love', 'a', 'dog', '.']</p>
                        <p><strong>2. 임베딩 (Embedding) :</strong><br>
                        각 토큰을 고유한 숫자 인덱스로 바꾸고, 임베딩 레이어를 통해 의미가 담긴 밀집 벡터로 변환<br>
                        ['i', 'love', 'a', 'dog', '.'] →[[0.1, ...], [0.5, ...], [0.2, ...], [0.9, ...], [-0.1, ...]]</p>
                        <p><strong>3. 문맥 벡터(Context Vector) 생성 :</strong><br>
                        [0.823, -0.156, 0.991, ...]<br>
                        문맥 벡터는 최종 결과물이 아니라, 인코더에서 디코더로 넘어가는 과정에서만 존재하는 임시 값입니다.
                    </aside>
                </div>
            </article>
            <article class="step-card card">
                <div class="step-number">2</div>
                <div class="step-card-content">
                    <h3>의미 번역 (디코더)</h3>
                    <p>디코더는 인코더가 만든 '문맥 벡터'의 의미를 참고하여,<br> 다음에 올 한국어 단어로 가장 확률이 높은 것을 순서대로 예측합니다.</p>
                    <aside>
                        <p>(번역 시작) → 나 예측<br>
                        나 다음에는 → 는 예측<br>
                        나, 는 다음에는 → 개 예측<br>
                        나, 는, 개 다음에는 → 를 예측<br>
                        ...<br>
                        (번역 종료) 예측</p>
                    </aside>
                </div>
            </article>
            <article class="step-card card">
                <div class="step-number">3</div>
                <div class="step-card-content">
                    <h3>출력 생성</h3>
                    <p>디코더가 '(번역 종료)' 토큰을 예측하면 문장 생성이 멈춥니다.<br> 그동안 순서대로 생성된 토큰들을 하나로 합치면 최종 번역 결과가 완성됩니다.</p>
                    <aside>
                        <ul>
                            <li><strong>최종 토큰 시퀀스 :</strong> ['나', '는', '개', '를', '사랑', '해', '.']</li>
                            <li><strong>번역 결과 :</strong> "나는 개를 사랑해 ."</li>
                        </ul>
                    </aside>
                    <p>이 전체 과정에서 모델이 'love'를 '사랑해'로, 'dog'를 '개'로 정확히 번역하는 능력은, 수많은 영어-한국어 문장 쌍을 학습하며 인코더와 디코더의 신경망 내부에 최적화된 수많은 가중치(Weight)에 그 모든 지식이 저장되어 있기 때문입니다.</p>
                </div>
            </article>
        </div>

        <section class="section-title fade-in-up">
            <h2>2. 감성 분석 (Sentiment Analysis) 👍/👎</h2>
            <p>텍스트에 담긴 긍정, 부정, 중립과 같은 감성적 뉘앙스나 의견을 분석하고 판단하는 기술입니다.</p>
        </section>

        <div class="steps-grid fade-in-up">
            <article class="step-card card">
                <div class="step-number">1</div>
                <div class="step-card-content">
                    <h3>입력 처리 (문장 의미 압축)</h3>
                    <p>분석할 문장 "이 영화 정말 최고예요!"가 입력되면,<br> 모델은 먼저 문장의 전체적인 의미를 나타내는 하나의 대표 벡터를 만듭니다.</p>
                    <aside>
                        <p><strong>1. 토큰화 (Tokenization):</strong><br>
                        "이 영화 정말 최고예요!" → ['이', '영화', '정말', '최고', '예요', '!']</p>
                        <p><strong>2. 임베딩 (Embedding):</strong><br>
                        각 토큰들이 의미를 가진 벡터의 나열로 변환됩니다.<br>
                        → [[0.1,...], [0.3,...], [0.9,...], [0.95,...], [0.2,...], [0.01,...]]</p>
                        <p><strong>3. 문장 벡터 생성:</strong><br>
                        모델은 단어 벡터들을 종합하여,<br> 문장 전체의 의미를 요약한 <strong>하나의 대표 벡터(Sentence Vector)</strong>를 생성합니다.<br>
                        → [0.67, -0.12, 0.88, ...]</p>
                    </aside>
                </div>
            </article>
            <article class="step-card card">
                <div class="step-number">2</div>
                <div class="step-card-content">
                    <h3>감성 분류 (Classifier)</h3>
                    <p>문장의 의미가 압축된 대표 벡터는 최종 판단을 내리는 <strong>분류기(Classifier)</strong>로 전달됩니다. 분류기는 이 벡터를 보고, 미리 학습된 <strong>가중치(Weight)</strong>를 사용하여 '긍정', '부정', '중립' 각 항목에 대한 확률 점수를 계산합니다.</p>
                    <aside>
                        <p>[문장 벡터] → [분류기] → <strong>{'긍정': 0.95, '부정': 0.04, '중립': 0.01}</strong></p>
                    </aside>
                </div>
            </article>
            <article class="step-card card">
                <div class="step-number">3</div>
                <div class="step-card-content">
                    <h3>출력 생성</h3>
                    <p>모델은 계산된 확률 중 가장 높은 값을 가진 클래스를 최종 결과로 선택합니다.</p>
                    <aside>
                        <ul>
                            <li><strong>최종 판단 :</strong> 가장 높은 확률: '긍정'</li>
                            <li><strong>분석 결과 :</strong> 긍정</li>
                        </ul>
                    </aside>
                    <p>모델이 '최고예요'라는 단어를 '긍정'으로 판단하는 능력은,<br> 수많은 긍정/부정 리뷰 데이터를 학습하며 <strong>가중치(Weight)</strong>에 그 패턴이 저장되었기 때문입니다.</p>
                </div>
            </article>
        </div>

        <section class="section-title fade-in-up">
            <h2>주요 Task 간의 관계</h2>
        </section>

        <div class="model-compare-grid fade-in-up">
            <article class="model-card card highlight-purple">
                <h3>감성 분석 vs 텍스트 분류 🍎</h3>
                <p>이 둘은 거의 같은 로직이라고 봐도 무방합니다. 더 정확히는, 감성 분석은 텍스트 분류의 한 종류입니다.</p>
                <aside>
                    <p><strong>텍스트 분류 :</strong><br> '과일'처럼 더 넓은 개념입니다. 텍스트를 정해진 카테고리 중 하나로 나누는 모든 작업을 포함합니다.</p>
                    <p><strong>감성 분석 :</strong><br> '사과'처럼 '과일'의 한 종류입니다. 텍스트 분류 중에서도 '긍정', '부정', '중립'이라는 특정 카테고리로 나누는 작업에 해당합니다.</p>
                </aside>
                <p>따라서 두 작업의 <strong>기술적인 구조(입력 처리 → 문장 벡터화 → 분류 → 출력)</strong>는 동일하며,<br> 단지 최종적으로 분류해야 할 카테고리의 종류만 다를 뿐입니다. (예: '긍정/부정' vs '스포츠/정치/경제')</p>
            </article>
            <article class="model-card card highlight-green">
                <h3>기계 번역 vs 텍스트 생성 ✍️</h3>
                <p>이 둘은 매우 비슷하지만, 기계 번역이 조금 더 복잡한 구조를 가집니다.<br> 핵심은 텍스트 생성 로직이 기계 번역의 '디코더(말하는 부분)'와 거의 동일하다는 것입니다. 비유하자면, '번역가'와 '작가'의 차이와 같습니다.</p>
                <aside>
                    <p><strong>텍스트 생성 (작가) :</strong><br> "옛날 옛적에"라는 시작 부분만 주면, 자신의 지식만으로 뒷이야기를 창작합니다. 입력은 단지 시작을 위한 짧은 '프롬프트(Prompt)'입니다.</p>
                    <p><strong>기계 번역 (번역가) :</strong><br>영어로 된 원작 소설을 <strong>먼저 완벽하게 읽고 이해(인코더)</strong>한 뒤, 그 의미를 보존하면서 한국어로 된 <strong>새로운 글을 생성(디코더)</strong>해야 합니다. 이해해야 할 명확한 '소스(Source)'가 있다는 점이 가장 큰 차이입니다.</p>
                </aside>
                <p>텍스트 생성은 <strong>'디코더'만으로 구현</strong>되는 경우가 많은 반면, <strong>기계 번역은 '인코더 + 디코더' 구조를 모두 사용합니다.</strong></p>
                <aside>
                    <ul>
                    <li><p><strong>텍스트 생성 :</strong> (짧은) 문맥 → (새로운) 문장</p></li>
                    <li><p><strong>기계 번역 :</strong> (하나의 온전한) 문장 → (다른 언어의 온전한) 문장</p></li>
                    </ul>
                </aside>
            </article>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const animatedElements = document.querySelectorAll('.fade-in-up');

            if ('IntersectionObserver' in window) {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('visible');
                            observer.unobserve(entry.target);
                        }
                    });
                }, {
                    threshold: 0.1
                });

                animatedElements.forEach(el => {
                    observer.observe(el);
                });
            } else {
                animatedElements.forEach(el => {
                    el.classList.add('visible');
                });
            }
        });
    </script>

</body>
</html>